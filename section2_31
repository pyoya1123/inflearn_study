이제 "회원 도메인 협력 관계" 에서
실제 구현 레벨로 내려오면, 이제 회원 클래스 다이어그램이 그려짐

멤버 서비스라는 역할을 인터페이스로 만들고, 그 다음에 그거에 대한 구현체로, MemberServiceImpl 를 만듬.
그 다음에, MemberRepository가 있는데, 이거는 회원 저장소임. 회원 저장소가 이게 이제 역할이 인터페이스가 되는거임.
이 MemberRepository에 대한 구현 클래스로, MemoryMemberRepository와 DBMemberRepository를 만듬.

회원 객체 다이어그램은 뭐냐면,
이게 실제 서버에 올라오면, 위에서 설명한건 클래스 다이어그램이고, 지금은 객체 다이어그램임.
객체 간에 어떤 메모리간의 참조들이 어떻게 되는지 그린거임.

클라이언트는 회원 서비스를 바라보고, 이 회원 서비스 impl은 메모리 회원 저장소를 바라보게 됨.
그니까 서버가 떠서 클라이언트 객체가 실제 사용하는 실제로 참조하는 주소값에 있는 인스턴스는
회원 서비스 impl인거임.

pdf보면 위에서 설명한것처럼
항상 그림이 개념적으로 3가지가 그려짐.
회원 도메인 협력 관계는 기획자들도 볼 수 있는 그림임.
이걸 바탕으로 개발자가 구체화해서 회원 클래스 다이어그램을 만드는거임.
이 클래스 다이어그램은 인터페이스와 구현체들이 다 보임.
그런데, 이 객체 다이어그램은 뭐냐면,
클래스 다이어그램은 실제 서버를 실행하지 않고 그 클래스들만 분석해서 볼 수 있는 그림임.
그런데, 이 구현체들, MemoryMemberRepository를 넣을지, DBMemberRepository를 넣을지
이런 것들은 동적으로 결정이 되는것들임.
무슨 말이냐면, 서버가 뜰 때 new 해가지고 뭘 넣을거야. 이때 결정이 되기 때문에
클래스 다이어그램 만으로는 판단하기가 어려움.
그래서 객체 다이어그램이란게 따로 있는거임.
그래서 서버가 실제 떠서 클라이언트가 실제 사용하는 멤버 서비스 impl, 그다음에 메모리 회원 저장소 이렇게 해서
이거는 실제 new로 만든 인스턴스들 끼리의 참조라고 보면 됨.
