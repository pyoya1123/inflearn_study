객체 지향 특징
- 추상화
- 캡슐화
- 상속
- 다형성

유연하고, 변경이 용이?
- 다형성 polymorphism

진짜 다형성에 대해서 알려주신다고 하심.
다형성의 실세계 비유
- 실세계와 객체 지향을 1:1로 매칭X
- 그래도 실세계의 비유로 이해하기에는 좋음
- 역할과 구현으로 세상을 구분
역할이 인터페이스고, 구현이 그 실제 인터페이스를 구현한 객체

운전자는 K3를 타다가, 아반떼로 차를 바꾸더라도
당연히 운전을 할 수 있음.
왜냐하면 자동차라는 역할에 대한 구현만 바꼈을 뿐임.
자동차가 바뀌더라도 운전자한테 영향을 끼치지 않음.
이게 중요한거임.
유연하고 변경이 용이하다. 이게 뭔뜻이냐면, 내가 자동차 역할을 k3에서 테슬라에서 바꾸더라도
운전자는 그냥 운전이 가능함. 이게 내가 테슬라를 산다고 하더라도 다른 운전면허를 따야 하는건 아님.
뭐 비행기를 탄다 하면 아예 새롭게 바뀌는거니까 따야겠지만,
자동차끼리 바뀔 때는 그냥 운전이 가능함. 왜 그러냐면,
자동차 역할의 인터페이스를 다 따라서 자동차를 구현했기 때문임.
운전자는 뭐만 아냐면, 자동차 인터페이스에 대해서만 알고있음.
자동차 역할에 대해서만 의존하고 있는거임.
그런데 여기서 진짜 중요한게 뭐냐면, 이 자동차라는 역할을 만들고, 이 구현을 분리한건 누구 떄문에 그런걸까?
운전자를 위해서 이렇게 한거임. 이 운전자를 클라이언트라고 하자. 클라이언트는 자동차의 내부 구조는 몰라도 됨.
그리고 이 뭔가 구현 애들이 내부적으로 바뀌더라도, 어쨌든 자동차 역할만 그대로 하고 있으면 내부적으로 바뀌더라도
클라이언트한테 영향을 안줌. 심지어, 아반떼를 테슬라로 바꾸더라도 운전자는 바꿀 필요가 없음. 그대로 운전할 수 있음.
다른 대상으로 변환이 가능하고, 심지어 완전히 새로운 자동차가 나오더라도 기존의 자동차 역할만 그대로 따라할 수 있으면
새로운 자동차가 나올 수 있음. 자동차 세상을 무한히 확장 가능한거임. 기름 자동차에서 전기 자동차가 나오더라도 내가 운전을 못하는게 아님.
그 자동차 역할만 구현하면 됨. 대상을 바꾸지 않고 새로운 자동차를 출시할 수 있는거임.
이거를 좀 더 디테일하게 얘기하자면, 클라이언트에 영향을 주지않고 새로운 기능을 제공할 수 있다.
왜 이게 가능하냐면, 역할과 구현으로 세상을 구분했기 때문에 가능한거임.
여기서 중요한건, 새로운 자동차가 나와도 클라이언트는 새로운걸 안배워도 되는거임. 클라이언트를 바꿀 필요가 없는거임.


또 다른 예시로, 내가 어떤 공연을 기획한다고 하자.
그리고 로미오 역할과 줄리엣 역할이 있음.
이 로미오라는 역할을 장동건이 할 수도 있고, 원빈이 할 수도 있는거임. 내가 할 수도 있고
아니면 다른 무명 배우로도 대체가 가능함.
로미오와 줄리엣 공연을 할 때, 배우는 대체가 가능해야함. 뭐 배우들이 다 아프다고 하더라도 최후의 경우에는 무명 배우라도 써야하는거임.
역할과 구현을 나눈거임.
이러면 변경 가능한, 대체 가능성이 생김. 이게 바로 유연하고 변경에 용이하다 라는 뜻임.
내부 구조를 몰라도됨.
줄리엣 역할을 김태희가 하든 송혜교가 하든 대본을 보고 이걸 따라서 하면 되는거지 누가 하든 상관이 없는거임.
로미오가 클라이언트고, 줄리엣이 서버라고 가정해보자.
줄리엣이라는 것의 구현이 바뀐다고 해도 로미오 역할에 영향을 주지 않음.
다른 대상으로 대체가 가능함. 이게 바로 유연하고 변경이 용이하다 라는거임.


객체의 협력이라는 관계부터 생각
- 혼자 있는 개체는 없다.
- 클라이언트는 요청하는 사람, 서버는 그 요청을 받아서 응답하는 사람.
- 수 많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가진다.
클라이언트는 동시에 서버가 가능함. 클라이언트가 a라는 서버한테 요청하고, 이 a라는 서버는
또 다른 서버들한테 요청을 할 수 있는데 이때 a라는 서버는 동시에 클라이언트도 될 수 있는거임.
여기서 응답이라는 개념이 데이터를 넣어서 리턴값이 꼭 없어도 됨. 내부적으로 뭐 프린트만 할 수도 있고,
어쨌든 여기서 a라는 서버가 다른 서버들한테 클라이언트로써 요청하는 행위도 응답이 될 수 있는거임.
이 행위를 한거가 그냥 요청에 응답을 한거임.

의존한다는 것이 뭐냐면, 내가 쟤를 알고 있다라는거임.

*다형성의 본질
- 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.
pdf 그림에서 보면 클라이언트는 파란색임. 그리고 빨간색이든지 초록색이든지 바꿀 수 있음.
멤버 서비스가 바라보는거를 메모리 멤버 레포지토리로 바꿀 수 있고,
jdbc 멤버 레포지토리로 바꿀 수 있는거임.
이게 다형성의 본질이다.

*역할과 구현을 분리 정리
세이브를 호출하면 메모리 멤버 레포지토리에서 메모리에만 저장을 하고 있다가,
그런데 나 디비에 저장하는게 필요한데? 라고 하면,
기존 멤버 서비스 로직을 전혀 손대지 않고,
jdbc 멤버 레포지토리 구현해서 딱 꽂으면,
그냥 디비에 저장하는 기능이 동작하는거임. 물론 jdbc 멤버 레포지토리를 개발하긴 해야할거임.
하지만 기존에 있던 클라이언트의 멤버 서비스나 다른 코드에 영향을 주지 않는다는거임.
이거를 확장 가능한 설계라고 볼 수 있음. 멤버 레포지토리의 구현체를 무한히 확장할 수 있다.
제일 중요한건 사실 인터페이스가 깨지면 다 끝나는거임. 그래서 잘 설계하는 것이 중요함.
이 역할을 잘 설계해야함.

*역할과 구현을 분리 한계
연극을 예로 들면 대본이 바뀌는거임.
이러면 대본 쓰는 사람들은 다 영향을 받는거임. 배우들.
자동차가 비행기로 바뀌면 다 뜯어 고쳐야함.


*스프링과 객체지향
- 다형성이 가장 중요하다.
    객체 지향의 꽃은 다형성임. 스프링은 이 다형성을 극대화해서 이용할 수 있도록 도와줌.
    pdf 참고하기