SRP : 단일 책임 원칙
single responsibility principle

OCP : 개방-폐쇄 원칙
open/closed principle
소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
의문점 -> 기능을 확장하려면 코드가 변경이 되어야하는데, 변경을 안해도된대. 어떻게 코드의 변경 없이 기능을 추가할 수 있는거지?
다형성을 예제로 해보자.
운전자 - 자동차
자동차가 기름차인 케이스에서 전기차로 바뀐다고 해도 운전자는 그냥 운전할 수 있음.
공연 문대
공연에 역할이 있고, 역할과 구현을 분리해놓으면
구현은 진짜 안돼도 무명 배우가 할 수 있음. 땜빵이 가능함.
다형성을 잘 활용해서 OCP 지킬 수 있음.
public class MemberService {
    // private MemberRepository memberRepository = new MemoryMemberRepository();
     private MemberRepository memberRepository = new JdbcMemberRepository();
    }
이 코드를 보면 OCP 원칙을 못지키고있음. 왜냐하면 JDBC 멤버 레포지토리로 바꾸려면 클라이언트 코드를 바꿔야함.
이걸 해결하기 위해서 DI랑 DI 컨테이너를 이용하는거임.

LSP 리스코프 치환 원칙
Liskov substitution principle
스코프 지향 원칙이라는게 있음.
프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
-> 간단하게 얘기하면 이런거임. 어떤 인터페이스가 있음. 근데 여기에 구현체가 있는거임. 예를 들어 자동차 인터페이스가 있음.
그러면 이걸 구현체가 구현을 하면 됨. 그런데 악셀이라는 기능을 구현해야함. 악셀은 밟으면 앞으로 가야함.
근데 이게 악셀을 밟으면 앞으로 가야한다고 했는데, 다시 악셀을 밟아도 뒤로 가는 차를 만들 수도 있는거임.
그런다고 해서 예를 들어서 악셀 한번 밟아서 +10만큼의 속도를 내는 기능을 만들었다고 치자.
우리가 되게 특별한 클래스를 만든거임. 그냥 악셀을 밟으면 -10이 되도록 만들어버린거임.
그래도 컴파일러 오류는 안남. 자바 컴파일러는 정상 작동을 할거임.
이 스코프 지향 원칙은 컴파일 단계를 단순히 얘기하는게 아님.
이 인터페이스 규약이 악셀은 앞으로 가야돼 라는 규약이 있는거임.
그러면 이 규약을 무조건 맞춰야함. 이게 기능적으로 그거에 대해서 보장을 해줘야함.
예를 들어서, 자동차 인터페이스의 악셀은 앞으로 가라는 기능임.
그러면 뒤로가게 구현을 해버리면 이건 LSP 리스코프 치환 원칙을 위배하는거임.
느리더라도 앞으로 가면 리스코프 치환 원칙을 맞추는거임.

ISP 인터페이스 분리 원칙
Interface segregation principle
특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
예를 들어보자. 자동차라는 인터페이스가 있음. 여기에는 운전과 관련된 인터페이스 기능들도 있고, 자동차 정비와 관련된 기능들도 쫙 있는거임.
이런 경우에 자동차 인터페이스 하나만 있는 경우엔 너무 큼.
이거를 딱 운전이라는 인터페이스와 정비라는 인터페이스 두개로 분리하는거임. 이러면 뭐가 좋냐면,
사용자 클라이언트를 운전자 클라이언트랑 정비사 클라이언트로 분류할 수가 있음.
그래서 예를 들어서, 정비하는데 문제가 있음. 기능을 바꿔야함. 이러면 정비 인터페이스에 대한 부분만 바꾸면 되지, 운전자 클라이언트까지 바꿀 필요가 없음.
그리고 또 기능이 너무 많으면 복잡하니까, 기능을 거기에 맞게 적당한 크기로 잘 쪼개는게 중요하다. 인터페이스도.
그래서 분리하면 정비 인터페이스 자체가 바껴도 운전자 클라이언트에 영향을 미치지 않음.
그리고 인터페이스가 명확해지고, 대체 가능성이 높아짐. 아무래도 덩어리가 크면 그걸 다 구현하기 힘든데, 덩어리가 작으면 요만한 기능만 살짝 구현하는건
구현체를 바꾸기 되게 쉬울거임. 그래서 인터페이스 분리 원칙이 있다.

DIP 의존관계 역전 원칙
Dependency inversion principle
의존성, 의존 관계로 표현을 하는데, 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다.". 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
쉽게 얘기하자면, 클라이언트 코드가 구현 클래스를 바라보지 말고, 인터페이스만 바라보라는 뜻임.
멤버 서비스가 멤버 레포지토리 인터페이스만 바라보고, 뭐 메모리멤버레포지토리나, JDBC 멤버 레포지토리에 대해서는 몰라야된다는거임.
앞서 이야기한 역할에 의존하는거랑 똑같은 얘기임.
운전자는 자동차 역할에 대해서만 알아야지, 뭐 K3, 테슬라, 아반떼 이런거에 굉장히 디테일하게 알 필요는 없는거임.
공연 같은 경우에도
원빈이 김태희랑만 공연 연습을 했어, 김태희 아니면 다른 사람이랑 공연하기 힘들어, 그러면 안되는거임. 뭐 공연 메뉴얼보고 연습하는게 아니라 둘이 따로 연습하는거임.
이러면 나중에 다른 배우로 바뀌면 대체 가능성이 없어짐. 그래서 역할과 구현을 철저하게 분리하도록 시스템도 그렇게 설계를 해야함. 언제든지 갈아낄 수 있도록.
그게 가능하려면 바로, 역할에 의존해야지, 구현에 의존하면 절대 안된다는거임. 배우가 대본에 의존해서 해야지, 대본이 아닌 다른 배우와 따로 대본 없이 연습하면
다른 배우로 바뀌어버리면 공연이 망하니까. 그래서 앞서 이야기한 역할에 의존해야한다는 것과 DIP는 똑같은거임.
객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수가 있음. 구현체에 의존하게 되면 변경이 아주 어려워짐.
앞에서 MemberRepository m = new MemoryMemberRepository(); 라는 코드에서도 분명 인터페이스에 의존하긴함.
그런데, 구현 클래스도 동시에 의존하고있는거임.
public class MemberService {
    // private MemberRepository memberRepository = new MemoryMemberRepository();
     private MemberRepository memberRepository = new JdbcMemberRepository();
    }
여기서도 멤버서비스가 분명히 멤버레포지토리 필드를 가지고 있지만,
오른쪽에 new를 해서 뭘 할당했냐? 메모리멤버레포지토리를 할당한거임. 이러면 멤버서비스는 메모리멤버레포지토리에도 의존하고 있는거임.
의존한다 라는게 뭐냐면, 내가 저 코드를 안다 라는거임.
그래서 지금 사실 이 멤버서비스는 멤버레포지토리 인터페이스만 아는게 아니라, 또 뭘 아냐면, 멤버 서비스는 메모리멤버레포지토리 까지 알고있는거임.
그래서 메모리멤버레포지토리를 다른거로 바꾸려고 할 때, 코드를 변경해야하는거임.
그래서 이제 MemberRepository m = new MemoryMemberRepository(); 이 멤버서비스 클라이언트가 구현 클래스를 직접 선택하고 있는거임. 직접 의존하고 있는거임.
DIP 위반은 무슨 뜻이다? 추상화에 의존해야지 구체화에 의존하면 안된다. 근데 분명 멤버 레포지토리 라는 추상화 인터페이스에 잘 의존하고 있음. 그런데,
추상화에도 의존을 하고, 구체화인 메모리멤버레포지토리에도 의존하고 있는거임. 둘 다 의존하고 있다. 이러면 DIP 위반이다.
코드를 변경해야하는 문제가 생기는거다.
그러면 어떻게 해야하지? 멤버서비스는 멤버레포지토리 인터페이스에만 의존하도록 설계를 해야한다. 그럼 어떻게 해?
이 어떻게를 뒤에서 설명해주신다고 하심.
